package main

import (
	"fmt"
	"sync"
	"time"
)

// Map to store Fibonacci numbers
var fibMap = make(map[int]int)
var mu sync.Mutex // Mutex to ensure safe concurrent writes

// Function to generate Fibonacci numbers within a given range
func generateFibonaccinew(start, end, producerID int, wg *sync.WaitGroup) {
	defer wg.Done()
	a, b := 0, 1
	for a <= end {
		if a >= start {
			// mu.Lock()
			fibMap[a] = producerID // Store Fibonacci number with producer ID
			// mu.Unlock()
		}
		a, b = b, a+b
		time.Sleep(100 * time.Millisecond) // Simulating processing delay
	}
	fmt.Printf("Producer %d finished generating\n", producerID)
}

func main() {
	limit := 150 // Maximum Fibonacci limit
	var wg sync.WaitGroup

	// Divide range into 3 sections for 3 producers
	part1, part2, part3 := limit/3, 2*limit/3, limit

	fmt.Printf("partitions: %d, %d, %d\n", part1, part2, part3)

	wg.Add(3)                                       // 3 producers
	go generateFibonaccinew(0, part1, 1, &wg)       // Producer 1
	go generateFibonaccinew(part1+1, part2, 2, &wg) // Producer 2
	go generateFibonaccinew(part2+1, part3, 3, &wg) // Producer 3

	wg.Wait() // Wait for all producers to finish

	// Print the Fibonacci numbers from the map
	fmt.Println("\nFibonacci Numbers (Stored in Map):")
	for num, producerID := range fibMap {
		fmt.Printf("Fibonacci: %d (Generated by Producer %d)\n", num, producerID)
	}
}
